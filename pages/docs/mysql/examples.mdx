---
title: Examples
description: Examples of common MySQL queries
tags: [MySQL]
layout: docs
---

## MD5 column

When working with large columns, performing indexed searches can be a challenge. One solution is to use an MD5 column to index the search. In this video, we will explore how an MD5 column can be used for an indexed search and provide step-by-step instructions on how to add an MD5 column to a MySQL table.

### The basics

To understand how an MD5 column works, let's start with a basic example. Let's consider a simple table called **urls** that contains only two columns: **id** and **url**. The url column is a **TEXT** column because it can be a very large value consisting of many thousands of characters.

If we want to perform a strict equality lookup on this table where the URL equals a specific value, we could run the following SQL query:

```sql
SELECT * FROM URLs WHERE url = 'specific_value';
```

Since the **url** column is not indexed, this query would result in a full table scan, searching through all the huge text columns. Unfortunately we can't just add a regular index to a **TEXT** column.

### MD5 hashes

One way to create an equality index for a **TEXT** column is to add an MD5 hash virtual generated column. An MD5 hash is a 128-bit value that can be calculated for any file, text string, or other data input.

To add an MD5 hash virtual generated column to the URLs table, we can run the following SQL query:

```sql
ALTER TABLE urls ADD COLUMN url_md5 CHAR(32) GENERATED ALWAYS AS (MD5(url));
```

This creates a new column called **url_md5** that contains the MD5 hash of the URL column. This column can be indexed using a B-tree index.

To add an index to the new **url_md5** column, we can use the following SQL query:

```sql
ALTER TABLE URLs ADD INDEX (`url_md5`);
```

Once indexed, we can perform an indexed search by running the following SQL query:

```sql
SELECT * FROM urls WHERE url_md5 = MD5('specific_value');
```

This query takes advantage of the index that was created on the **url_md5** column, resulting in a much faster and more efficient search.

### Binary strings

When creating an MD5 hash virtual generated column, it is important to specify the data type. Since we're only ever going to be comparing sets of bytes rather than characters, we can use **BINARY(16)** for a more efficient search.

```sql
ALTER TABLE urls ADD COLUMN url_md5 binary(16) GENERATED ALWAYS AS (UNHEX(MD5(url)));
```

Then we can add an index to the new binary url_md5 column using the following SQL query:

```sql
ALTER TABLE urls ADD INDEX (url_md5);
```

And perform an indexed search using the following SQL query:

```sql
SELECT * FROM urls WHERE url_md5 = UNHEX(MD5('specific_value'));
```

This binary search is more efficient and faster than the previous example using CHAR.

## MD5 over multiple columns

Consider the example of a table that stores normalized addresses. The table consists of four columns – **primary_line**, **secondary_line**, **urbanization**, and **last_line**. The goal is to store unique addresses and only keep the pretty, normalized version of an address. However, since there is no natural ID or other unique identifier, we need to create our unique ID.

### Creating the MD5 hash

To generate the MD5 hash, we create a new column, simply called MD5. Since the table includes binary 16, we will use that for the MD5 hash column. We can do this by running the following command:

```sql
ALTER TABLE addresses ADD COLUMN md5 BINARY(16) GENERATED ALWAYS AS (
  UNHEX(MD5(
    CONCAT_WS('|', primary_line, secondary_line, urbanization, last line)
  ))
);
```

Note that we are using MD5 hash concatenated with separator (**|**). The first value passed in is the separator. We use the **CONCAT_WS** function to combine all four columns and then generate the MD5 hash.

### Making the MD5 hash unique

Since we want to ensure that we store only unique values, we can add a unique index on the MD5 column. This is done by running the following command:

```sql
ALTER TABLE addresses ADD UNIQUE INDEX (md5);
```

This ensures that we can perform strict equality checks across multiple columns since we have one logical unit with one logical ID created through this new column.

### Binary vs. character columns

Note that because the MD5 column is a binary column (a string of bytes, not characters), we must use the **UNHEX** function to convert the characters to a binary string.

By using this method to create unique MD5 hashes from multiple columns, we can now enforce uniqueness and perform lookups faster than a composite index across multiple character columns. This also saves us from having to maintain a more complex index structure.

Creating an MD5 hash from multiple columns is a powerful tool that can be used in various applications to achieve fast and efficient search results.

## Bitwise operations

We explored an alternative solution to using a JSON column to store multiple flags in a single field. Using a tiny integer column to store multiple bits of information in a single field is an efficient way to save space in the database. However, it comes with some tradeoffs, including reduced readability and additional application logic overhead. Whether or not to use this approach depends on your specific use case and the tradeoffs you are willing to make!

### Storing flags in a TINYINT column — a tradeoff between space and readability

When designing a database, it is often necessary to store "flags," or true/false values. One way to do this is to create a separate column for each value, but as the number of flags increases, this approach becomes impractical. One solution is to use a JSON column to store all the flags in a single field. However, this approach comes at the cost of increased space usage. In this video, we explore an alternative solution that uses a tiny integer column to store multiple bits of information in a single field.

### Using a tiny integer column

Suppose we have a **users** table and we want to add a column to store true/false flags. Instead of using a JSON column, we can use a tiny integer column to store multiple bits of information in a single field. Let's see how this works.

First, we need to add a column to the users table:

```sql
ALTER TABLE users ADD COLUMN flags TINYINT UNSIGNED DEFAULT 0;
```

Notice that we're setting the default value to 0 and making the column **tinyint unsigned** to store only positive integers.

After adding the column, we can store multiple flags in a single integer. To do this, we need to understand how bits and bytes work.

### Bits and bytes

A byte is a unit of digital information that consists of eight bits. A bit is a binary digit that can be either 0 or 1. By manipulating the bits in an integer, we can store multiple flags in a single field.

For example, suppose we have the following eight flags:

1. dark_mode
2. super_admin
3. notification_opt_in
4. metered_billing
5. rollout_chat
6. experiment_blue
7. log_verbose
8. new_legal_disclaimer

We can assign each flag to a bit in the integer column as follows:

```sql
00000000
│││││││└─ Bit 1: dark_mode
││││││└── Bit 2: super_admin
│││││└─── Bit 3: notification_opt_in
││││└──── Bit 4: metered_billing
│││└───── Bit 5: rollout_chat
││└────── Bit 6: experiment_blue
│└─────── Bit 7: log_verbose
└──────── Bit 8: new_legal_disclaimer
```

Using this mapping, we can store up to eight flags in a single byte. To store multiple flags, we need to turn on the corresponding bits.

For example, suppose a user has turned on the **dark_mode** and **rollout_chat** flags. To represent this, we need to turn on bits 1 and 5. Using binary notation, this would look like this: **00010100**.

```sql
   ┌───── Bit 5: rollout_chat            ┐
   │                                     ├─ These are set to 1, therefore true
   │   ┌─ Bit 1: dark_mode               ┘
00010001
│││ ││└── Bit 2: super_admin             ┐
│││ │└─── Bit 3: notification_opt_in     │
│││ └──── Bit 4: metered_billing         ├─ These are set to 0, therefore false
││└────── Bit 6: experiment_blue         │
│└─────── Bit 7: log_verbose             │
└──────── Bit 8: new_legal_disclaimer    ┘
```

To convert this to an integer value, we can add up the decimal value of each bit that is turned on. In this case, that would be 1 + 16 = 17.

```sql
00010001
   │   └─ dark_mode    = 1
   └───── rollout_chat = 16
                        ────
                         17
```

We can store this value, 17, in the flags column for this user.


### Querying the flags

To query the flags, we can use bitwise operators. For example, to find all users who have the **dark_mode** flag turned on, we can use the following SQL statement:

```sql
SELECT * FROM users WHERE flags & 1 = 1;
```

In this statement, we use the bitwise AND operator (**&**) to compare the value of the **flags** column with the binary value of 1 (**00000001**), which represents the dark_mode flag. If the result of the bitwise AND operation is 1, it means that the **dark_mode** flag is turned on, and we include that user in the result set.

Similarly, to find all users who have both the **dark_mode** and **rollout_chat** flags turned on, we can use the following SQL statement:

```sql
SELECT * FROM users WHERE flags & 17 = 17;
```

In this statement, we use the bitwise AND operator (**&**) to compare the value of the **flags** column with the binary value of 17 (**00010100**), which represents both the **dark_mode** and **rollout_chat** flags. If the result of the bitwise AND operation is 17, it means that both flags are turned on, and we include that user in the result set.

### Tradeoffs

Using a tiny integer column to store multiple flags in a single field is an efficient way to save space in the database. However, it comes with some tradeoffs.

- **Reduced readability**: The binary representation of flags in the **flags** column is not human-readable. It can be difficult to interpret the meaning of the flags without consulting a mapping table.

- **Limited number of flags**: The number of flags that can be stored in a single byte is limited to eight. If we need to store more flags, we need to use a larger integer column or a JSON column.

- **Application logic overhead**: To use the bitwise operators to query the flags, we need to write additional application logic that maps the flags to their corresponding bit values. This can add complexity to the codebase.

## Timestamps versus booleans

As a developer, one of the challenges you face regularly is deciding which data type to use in your database. While the choice often depends on the specifics of the project and its requirements, it is essential to weigh the advantages and disadvantages of each option. In this video, we'll explore using timestamps instead of booleans and the tradeoffs that come with them.

To better illustrate this, let's consider an example where we'll create a table named "posts." This table will have several columns, but for demonstration, we'll focus on the "is_archived" column, which indicates whether a post has been archived.

```sql
CREATE TABLE posts(
  title VARCHAR(125),
  -- ....
  is_archived BOOLEAN
);
```

Initially, we set the "is_archived" column as boolean, which is a useful data type. It allows us to store a true/false value in a single bit, providing an optimal storage solution for storing binary values. However, using timestamps instead of booleans has its benefits too.

### Benefit of using timestamps instead of booleans

When we change the data type to timestamps, we get access to an extra piece of information. Instead of just storing a boolean value, we get to store an archive timestamp, which tells us when the post was archived.

```sql
CREATE TABLE posts(
  title VARCHAR(125),
  -- ....
  archived_at timestamp null
);
```

With this in place, we can still use the archived_at column as if it is a boolean value with the following query:

```sql
SELECT * FROM posts WHERE archived_at IS NULL;
```

This query returns all unarchived posts, which is equivalent to the boolean query

```sql
SELECT * FROM posts WHERE is_archived = false;
```

However, the **archived_at** column provides us with more information, namely the time at which the post was archived, which could be useful in the long run.

### The tradeoffs of using timestamps

While using timestamps provides us with extra information, it has a few tradeoffs that we must consider.

A timestamp column uses four times more storage space than a boolean column, which uses only one byte. As a result, when using timestamps, we need to be mindful of the amount of storage space we use. In a large database, the extra space usage can be significant but it usually doesn't make too much of a difference.

If we decide to put an index on the **is_archived** column, it is unlikely to be selective enough to benefit the query. Most posts won't be archived, so querying for posts that aren't archived will not use the index. This is another reason why using a slightly larger column doesn't matter that much, as it's unlikely to be indexed.

## Claiming rows

In some situations, multiple workers may need to claim rows in a database, indicating that they are currently working on them and others should not interfere. This can be especially common with sets of unprocessed rows, such as imports or emails. While MySQL may not be the best queue driver for this type of scenario, it is certainly possible to use it to claim rows in a lightweight way.

Let's take a look at how to claim rows in a MySQL database and ensure that each row is only claimed once.

### Setting up the imports table

We'll start by creating an imports table that will hold unprocessed rows. This table will have columns for a file name, owner, available, started at, and finished at timestamps.

```sql
CREATE TABLE imports (
  id INT NOT NULL AUTO_INCREMENT,
  filename VARCHAR(255),
  owner INT DEFAULT 0,
  available TINYINT DEFAULT 1,
  started_at TIMESTAMP,
  finished_at TIMESTAMP,
  PRIMARY KEY (id),
  INDEX available_owner (available, owner)
);
```

Note that we have included a composite index on the available and owner columns in order to make our queries more efficient.

### Selecting available rows

Our first step is to select any available rows for our workers to claim. We can do this by running the following query:

```sql
SELECT
  *
FROM
  imports
WHERE
  available = 1
LIMIT 1;
```

This query retrieves the most recent unclaimed row from the table. However, it is important to note that **this method is flawed**, as it does not guarantee that another worker has not already claimed this row by the time our worker updates it.

### Updating claimed rows

Instead of selecting a row and then updating it, we can issue a blind update that claims the row as soon as it is found. We can do this using the following query:

```sql
UPDATE imports
SET
  owner = 32, -- unique worker id
  available = 0
WHERE
  owner = 0
  AND
  available = 1
LIMIT 1;
```

In this example, we are claiming the row for worker #32 by setting the owner column to 32 and the available column to 0. On your application side, you would need to make sure each worker process has a unique id. We are also only claiming one row at a time with the LIMIT 1 clause.

### Checking claimed rows

Once a row has been claimed, we can ensure that only the owner of the row is able to modify or process it. We can do this by selecting rows where the owner is equal to the worker ID.

```sql
SELECT
  *
FROM
  imports
WHERE
  owner = 32;
```

This query will only return rows where the owner is equal to 32, indicating that worker #32 is currently working on that row.