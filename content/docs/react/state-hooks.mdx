---
title: State Hooks
description: Hooks that remember information that is stored in components and refresh them when information is changed
---

For storing information in component use one of these Hooks:

- `useState` declares a state variable that you can update directly.
- `useReducer` declares a state variable with the update logic inside a reducer function.

## useState

useState returns an array with exactly two values:

1. The current state.
2. The set function that lets you update the state to a different value and trigger a re-render.

### Set function

- The set function **only updates the state variable for the next render**. If you read the state variable
  after calling the set function, [you will still get the old value](#example-update-value-in-current-render) that was on the screen before your call.

- If the new value is identical to the current state, React will **skip re-rendering the component and its children**.

- React updates the screen **after all the event handlers have run** and have called their set functions.
  This prevents multiple re-renders during a single event.

- Calling the set function during rendering is only allowed from within the currently rendering component. [See an example below.](#example-storing-information-from-previous-renders)

- State is considered read-only, so **you should replace it rather then mutate your existing objects.** [don't mutate state](#example-updating-objects-and-arrays-in-state)

- React saves the initial state once and ignores it on the next renders. [don't call functions in initialState](#example-avoiding-recreating-the-initial-state)

- You can reset a component’s state by passing a different key to a component. [Resetting state with a key](#)

### Example: basic

```tsx
function Calculator() {
  const [sum, setSum] = useState(0)

  function handleClick(value) {
    setSum((a) => a + value)
  }
  // ...
}
```

### Example: update value in current render

```tsx
function handleClick() {
  console.log(count) // 0

  setCount(count + 1) // Request a re-render with 1
  console.log(count) // Still 0!

  setTimeout(() => {
    console.log(count) // Also 0!
  }, 5000)
}
```

### Example: Storing information from previous renders

```tsx
import { useState } from "react"

export default function CountLabel({ count }) {
  const [prevCount, setPrevCount] = useState(count)
  const [trend, setTrend] = useState(null)
  if (prevCount !== count) {
    setPrevCount(count)
    setTrend(count > prevCount ? "increasing" : "decreasing")
  }
  return (
    <>
      <h1>{count}</h1>
      {trend && <p>The count is {trend}</p>}
    </>
  )
}
```

### Example: Updating objects and arrays in state

```tsx
// Don't mutate an object in state like this:
form.firstName = "Taylor"

// Replace state with a new object

setForm({
  ...form,
  firstName: "Taylor",
})
```

### Example: Avoiding recreating the initial state

The result of createInitialTodos() is only used for the initial render,
you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations.

```tsx
function TodoList() {
  // React will call this function on every render.
  const [todos, setTodos] = useState(createInitialTodos())

  // React will only call it during initialization.
  const [blogs, setBlogs] = useState(createInitialBlogs);

  // ...
}
```

### Example: Resetting state with a key

When the key changes, React re-creates the Form component (and all of its children) from scratch, so its state gets reset.

```tsx
export default function App() {
  const [version, setVersion] = useState(0);

  function handleReset() {
    setVersion(version + 1);
  }

  return (
    <>
      <button onClick={handleReset}>Reset</button>
      <Form key={version} />
    </>
  );
}
```

### Example: How to store functions

This example below will call function

```tsx
const [fn, setFn] = useState(someFunction);

function handleClick() {
  setFn(someOtherFunction);
}
```

To store functions, you need to do something like this:

```tsx
const [fn, setFn] = useState(() => someFunction);

function handleClick() {
  setFn(() => someOtherFunction);
}
```

## useReducer

This hook is similar to useState, but it is used when you have complext state logic.

### Example: basic

```tsx /appDir: true/
function Counter() {
  const [counter, setCounter] = useReducer<Reducer<number, number>>(
    (prev, next) => {
      if (next <= 5) return next
      return prev
    }, 0)

  return (
    <div>
      <p>Counter: {counter}</p>
      <button onClick={() => setCounter(counter + 1)}>Add to counter</button>
    </div>
  )
}
```

### Example: Todo

```tsx showLineNumbers /appDir: true/
const changeText = (newText: string) => ({
  type: "CHANGE_TEXT" as const,
  payload: { newText },
})

const addTodo = () => ({
  type: "ADD_TODO" as const,
})

const changeTodo = (id: number) => ({
  type: "UPDATE_TODO" as const,
  payload: { id },
})

const deleteTodo = (id: number) => ({
  type: "DELETE_TODO" as const,
  payload: { id },
})

type Action =
  | ReturnType<typeof changeText>
  | ReturnType<typeof addTodo>
  | ReturnType<typeof changeTodo>
  | ReturnType<typeof deleteTodo>
type State = {
  draft: string
  todos: { id: number; text: string }[]
}

const initialState: State = {
  draft: "",
  todos: [],
}

function reducer(state: State, action: Action) {
  switch (action.type) {
    case "CHANGE_TEXT": {
      return {
        ...state,
        draft: action.payload.newText,
      }
    }
    case "ADD_TODO": {
      return {
        todos: [...state.todos, { id: state.todos.length, text: state.draft }],
        draft: "",
      }
    }
    case "UPDATE_TODO": {
      return {
        todos: state.todos.map((t) => {
          if (t.id === action.payload.id) {
            return { ...t, text: state.draft }
          } else {
            return t
          }
        }),
        draft: "",
      }
    }
    case "DELETE_TODO": {
      return {
        todos: state.todos.filter((t) => t.id !== action.payload.id),
        draft: "",
      }
    }
    default: {
      throw Error("Unknown action: " + action["type"])
    }
  }
}

export default function ToDo() {
  const [state, dispatch] = React.useReducer<React.Reducer<State, Action>>(
    reducer,
    initialState
  )

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    dispatch({
      type: "CHANGE_TEXT",
      payload: { newText: e.target.value },
    })
  }
  const handleAddTodo = () => {
    dispatch({ type: "ADD_TODO" })
  }
  const handleUpdateTodo = (id: number) => {
    dispatch({ type: "UPDATE_TODO", payload: { id } })
  }

  const handleDeleteTodo = (id: number) => {
    dispatch({ type: "DELETE_TODO", payload: { id } })
  }

  return (
    <div>
      <input
        type="text"
        className="border-2"
        value={state.draft}
        onChange={handleInputChange}
      />
      <button onClick={handleAddTodo}>Add todo</button>

      {state.todos.map((todo) => (
        <div key={todo.id} className="flex gap-2">
          <p>{todo.text}</p>
          <button
            className="bg-yellow-500"
            onClick={() => handleUpdateTodo(todo.id)}>
            Update todo
          </button>
          <button
            className="bg-red-500"
            onClick={() => handleDeleteTodo(todo.id)}>
            Delete todo
          </button>
        </div>
      ))}
    </div>
  )
}
```
