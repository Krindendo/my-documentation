---
title: Indexes
description: The building blocks of database performance
---

Indexes are an entirely separate data structure that maintain a **copy of part of your data**. When you create an index, it creates a second data structure, which is different from your primary data structure (the table). It's crucial to understand that each index maintains a copy of part of your data, which means that if you have multiple indexes, **there will be multiple copies of different parts of your data.**

Moreover, indexes have a pointer back to the row. It's necessary for an index to know how to get back to the table because it maintains a copy of part of your data.

Unlike schema design, you cannot look at your data and decide what indexes to put on your table. Instead, you have to examine your queries to determine which indexes will perform the best. In other words, indexing should be driven by the access patterns of your application.

**Rules for creating indexes**

As far as the rules for creating indexes are concerned, you should aim to create as many indexes as you need. Indexes are the best tool for creating a performant query, which usually translates into a performant application. However, you should also create as few as you can get away with because creating too many indexes can impact the performance.

It's essential to strike a balance between how many indexes you need and how few you can get away with. Establishing this balance depends on the size of your database, frequency of updates, and other factors that might influence the performance of your application. With that in mind, it's crucial to look at access patterns when deciding which indexes to create.

### B+ trees 

Indexes speed up data retrieval. Without an index, MySQL would have to read through the entire table to find a specific value.

This data structure resembles a [tree structure with nodes](/algorithms/data-structures/trees), and it functions as a map for accessing specific data in a table. To demonstrate how B+ trees work, let's visualize an index on the people table. You can see that it looks like a tree, with the root node at the top and the leaf nodes at the bottom.

The root node isn't very relevant to us right now, so we'll shift our focus to the leaf nodes. Each name in the table has its own corresponding node in the B+ tree. The leaf nodes contain the data that we have indexed, in this case, first names.

<img src="/images/docs/BplusTrees.png" alt="Stack example" className="my-6" />

**Searching**

It is just [tree binary search](/algorithms/data-structures/trees).

Let's assume we want to search for the name "Suzanne."

Starting at the root node, we'll compare "Simon" to "Suzanne." As "Suzanne" is later in the alphabet than "Simon," we'll head down the right side of the tree. We'll then compare "Tyler" to "Suzanne." Since "Suzanne" comes before "Tyler," we'll head down the left side. We'll find the node with the name "Suzanne" and compare it to itself. Since the values match, we'll head down the right side of the tree and land where we want to be.

**This algorithm allows us to skip over many of the leaf nodes at the bottom and only look at a few nodes. Without an index, we'd have to read through every single row to find the name "Suzanne."**

B+ trees build up a secondary data structure that optimizes searching for specific values. By creating an index on the first name field, we've optimized this secondary data structure for searching first names.

### Primary keys

A primary key is a unique identifier for each row in the table, and it plays an important role in how your data is stored and accessed.

```sql
create table users (
    id bigint unsigned auto_increment primary key,
    name varchar(155)
)
```

Keep in mind that while this is the simplest method, there are some things to be aware of. For example, MySQL will automatically make the primary key column not nullable, and it will create a unique index for the column. This means that you don't need to create a separate index for the primary key, and doing so could result in duplicated indexes.

**primary keys vs. secondary keys**

A secondary key is any index that is not the primary key. It's used to improve performance when searching for specific data in your table.

A primary key, on the other hand, is a unique identifier for each row in the table.

**Why choosing the right primary key matters**

The primary key determines how your data is stored on disk. In MySQL's InnoDB engine, the primary key is a "clustered index," which means that the data is physically ordered based on the values in the primary key column. This makes primary key lookups incredibly fast, but it also means that every time you insert a new row the tree structure has to be updated.

Choosing a good primary key is important because it can impact the performance of your queries. For example, using a GUID or hash as a primary key can be slow because it requires more storage space and can lead to slower insert performance as the tree has to be rebalanced. On the other hand, using an auto-incrementing integer as a primary key can be more efficient because it requires less storage space and new values always go at the end.


### Secondary keys

Secondary key (also known as indexes) is any key (or index) that is not the primary key. **It has a special relationship to the primary key.**

A secondary key is simply any index that is not the primary key of a table. Every MySQL table has one primary key and can have multiple secondary keys. It is crucial to note that primary and secondary keys are still related to each other, and understanding this relationship is crucial to working with them effectively.

Example: 

Consider a people table with the columns id, name, and email. We can create a secondary key on name using the following MySQL query:

```sql
ALTER TABLE people ADD INDEX (name);
```

An index on the name column is now created, and we can use it to query the people table.

Here is a sample query that retrieves all the rows of a person whose name is Suzanne using the secondary key:

```sql
SELECT * FROM people WHERE name = 'Suzanne';
```

**How the query works**

When executed, MySQL uses the B-tree index created on the name column to locate the row with the specified name. It begins at the root node of the index and works its way down through the branches until it reaches the leaf node representing the row with the matching name.

Now, since the name column is a secondary key, it does not store all the data required for the query. It only contains the indexed column name and a pointer to the rest of the row. MySQL must perform a second lookup to retrieve the rest of the data related for that row.

Every secondary key has the primary key appended to it, as each leaf node in the secondary key contains a pointer back to the row. When you perform a query with a secondary key, MySQL first traverses the secondary index tree, finds the corresponding primary key, and then looks up that primary key in the primary index tree to retrieve all the data.

**Importance of compact primary keys**

As previously mentioned, each leaf node in a secondary key has the primary key appended to it. Therefore, it is crucial to choose compact primary keys that require a minimal amount of storage space.

### Primary key data types

**What data type you should use for primary keys in MySQL**

An essential decision when designing a database schema is choosing the data type for the primary key. The primary key serves as a unique identifier for each record in a table, and it is a critical element in database design. As such, it is essential to choose the right data type that meets the database's requirements and avoid potential pitfalls that could lead to performance issues or other problems down the road.

**The benefits of unsigned big integers**

The recommended practice for primary keys is to use **unsigned big integers.** Unsigned big integers provide virtually infinite room to grow, which is essential because running out of primary key space is a significant issue for databases. Additionally, they allow for auto-incrementing, which preserves a natural order for the records, ensuring that the primary key B-tree isn't split unnecessarily.

**Choosing strings as primary keys**

Choosing a string data type, such as a UUID or a GUID, as a primary key can be tempting, but it has potential pitfalls. The problem with these types of data is their size, which means the indexes of the table grow enormously as a result of them. Additionally, the B-tree may have to be rebalanced if insertions occur in the middle of the table.

If you want to use a string as a primary key, you should look for a UUID or GUID that is time-sorted, so all new records go to the end of the table, rather than in the middle. ULIDs are a new option for sorted GUIDs that are worth considering.

**Obfuscation of the primary key**

Some developers might use UUIDs or GUIDs to obfuscate the primary key when exposed in public APIs or URLs. This approach is not ideal, as the primary keys are better used for unique identification of each record in the database while leaving the obfuscation to a separate column.

### Where to add indexes

We've said before that your queries should drive your indexes. What does this mean? It means that you should start by analyzing the access patterns of your application before deciding where to put indexes.

Before adding an index, ask yourself, which queries are you running frequently and which tables are they accessing? By analyzing the access patterns of your queries, you can better determine which indexes will be most useful. Keep in mind that not all queries require indexes, and adding too many indexes can actually harm your database's performance.

Here are some general rules of thumb to consider when deciding whether or not to use an index:

- Do not assume that anything that shows up in the where clause of a query should have an index. Consider all queries being run and their respective access patterns.

- Do not create an index on every column. This will slow down inserts by functionally duplicating your table. It also won't help reads as much as you'd hope.

- Do consider the entire query when deciding which columns to index. This includes sorting, grouping, and joining.

- Do not worry about trying to create the perfect index for every query. It may not always be possible, and sometimes you will have to rework the queries to take advantage of existing indexes.

```sql
alter table people add index birthday_index (birthday);
```
This creates an index named birthday_index on the birthday column of the people table.

Example: 

Let's take a closer look at how indexes can optimize specific queries. We will be using the people table we used in the previous section, which includes an id, first_name, last_name, state, email, and birthday column.

```sql title="Equality"
select * from people where birthday = '1989-02-14';
```

```sql title="Ranges"
select * from people where birthday >= '2006-01-01';
```

```sql title="Ranges"
select * from people where birthday between '2006-01-01' and '2006-12-31';
```

```sql title="Sorting"
select * from people order by birthday limit 10;
```
This query will return the first 10 rows of the people table sorted by the birthday column. Since there is an index on the birthday column, MySQL can use this index for sorting instead of doing a full table scan.

```sql title="Grouping"
select birthday, count(*) from people group by birthday;
```

This query groups all people by their birthdays and returns a count of all people born on the same day. Once again, since there is an index on the birthday column, MySQL can use this index to group rows together instead of doing a full table scan.

### Index selectivity

Indexing is a crucial aspect of MySQL database optimization. It involves adding indexes to important columns to speed up query performance. The process of selecting the best index for specific database columns can be a bit tricky.

Cardinality refers to the number of distinct values in a particular column that an index covers. When you use the SHOW INDEXES command in MySQL, the cardinality column in the output shows you the approximate total number of unique values in a given index column. 

```sql title="Example of cardinality of column birthday"
select count(distinct id) / count(*) from people
select count(distinct birthday) / count(*) from people
```

Selectivity, on the other hand, refers to how unique the values in a column are. It is a measure of how selective an index can be in narrowing down results when queried. The higher the selectivity of an index, the better it is for optimizing query performance.

Knowing the concepts of cardinality and selectivity can help us make informed decisions when optimizing database performance. For instance, we can use the information on the selective value of a column to determine whether or not to put an index on it.

Suppose we have a table with a type column that has two possible values, user and admin, with most rows having the value user. In this case, putting an index on the type column may not be the best approach to find rows with type = "user" since most of the rows contain the same value. The index is not highly selective for user, but it is highly selective for admin!

Furthermore, if we're stuck and can't figure out why an index isn't being used, we can check the selectivity of the index in question. **If the selectivity is low, it is most likely that MySQL decided to read the table, assuming the index would be slower than a full table scan.**

### Prefix indexes

By indexing just a part of a string column, you can make the index much smaller and faster. For example, indexing only the first four or five characters of a string reduces the size of the index while potentially maintaining the selectivity.

Prefix indexing is especially suitable for long, evenly distributed, and unique strings, such as UUIDs and hashes.

To create a prefix index in MySQL, you have to specify the prefix length you want to index. Suppose we have a people table with a string column for the first name, and we want to index the first five characters only:

```sql
ALTER TABLE people ADD INDEX (first_name(5));
```

**Determining prefix lengths**

Now that we know how to create prefix indexes let's determine the ideal prefix length of a column. To determine the prefix length of a column to index, we have to calculate the overall selectivity of the column and compare it to the selectivity of the prefix.

Example: 

Let’s consider an example where we have a table with a column first_name, consisting of 3009 unique first names out of 500,000 people. In this case, the selectivity of the column is:

```sql
SELECT COUNT(DISTINCT first_name) / COUNT(*) as selectivity from people;
```

Running the above query gets a selectivity of 0.0060.

Now, we can experiment with different lengths in the LEFT() function to determine the smallest prefix length that provides close to full selectivity. Here's a sample of prefixes you can test:

```sql
SELECT COUNT(DISTINCT LEFT(first_name, 4)) / COUNT(*) as left4 from people; -- 0.0037
SELECT COUNT(DISTINCT LEFT(first_name, 5)) / COUNT(*) as left5 from people; -- 0.0048
SELECT COUNT(DISTINCT LEFT(first_name, 6)) / COUNT(*) as left6 from people; -- 0.0054
SELECT COUNT(DISTINCT LEFT(first_name, 7)) / COUNT(*) as left7 from people; -- 0.0058
```

As you increase the prefix length of columns values, we'll notice that the selectivity will also increase. Therefore, we can determine the ideal index for the column based on the minimum prefix length that achieves close to full selectivity. Ideal prefix length is 6.

**Drawbacks of using prefix indexing**

Prefix indexes are not suitable for ordering or grouping as the index does not contain the full string value, and therefore cannot be used. This makes it impossible to use a prefix index to sort results by the given column. (You can still sort by the column, but it will not use the index.)

### Composite indexes

Composite indexes cover multiple columns instead of having individual indexes on each column.

```sql
-- single indexs
ALTER TABLE people ADD INDEX first_name (first_name);
ALTER TABLE people ADD INDEX last_name (last_name);
ALTER TABLE people ADD INDEX birthday (birthday);

-- multi index
ALTER TABLE people ADD INDEX multi (first_name, last_name, birthday);

SHOW INDEXES FROM people;

| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Index_type |
|--------|------------|----------|--------------|-------------|-----------|-------------|------------|
| people |          1 | multi    |            1 | first_name  | A         |        3107 | BTREE      |
| people |          1 | multi    |            2 | last_name   | A         |      419540 | BTREE      |
| people |          1 | multi    |            3 | birthday    | A         |      491583 | BTREE      |
```


When you inspect the indexes on the people table, you'll notice the multi index with a sequence in the index column. This sequence indicates the order of the columns in the index, which is crucial for how the index can be used.

**Rules for composite indexes**

1. Left-to-right, no skipping - MySQL can only access the index in order, starting from the leftmost column and moving to the right. It can't skip columns in the index.

2. Stops at the first range - MySQL stops using the index after the first range condition encountered.

**Analyzing index usage**

To understand how MySQL uses composite indexes, you can use the **EXPLAIN** statement.

```sql
EXPLAIN SELECT * FROM people WHERE first_name = 'Aaron' AND last_name = 'Francis';

| id | select_type | table  | type | possible_keys | key   | key_len | ref         | rows | filtered |
|----|-------------|--------|------|---------------|-------|---------|-------------|------|----------|
|  1 | SIMPLE      | people | ref  | multi         | multi | 404     | const,const |    1 |   100.00 |
```

The EXPLAIN output shows that the multi index is being used, with a key length of 404 bytes. This indicates that MySQL is using both the first_name and last_name parts of the index.
If we add birthday to the mix, the key_len jumps to 407.

```sql
EXPLAIN SELECT * FROM people WHERE first_name = 'Aaron' AND last_name = 'Francis' and birthday = '1989-02-14';


| id | select_type | table  | type | possible_keys | key   | key_len | ref               | rows | filtered |
|----|-------------|--------|------|---------------|-------|---------|-------------------|------|----------|
|  1 | SIMPLE      | people | ref  | multi         | multi | 407     | const,const,const |    1 |   100.00 |
```

However, if you change the query to include a range condition on last_name, then the key_len drops back down to 404.

```sql
EXPLAIN SELECT * FROM people WHERE first_name = 'Aaron' AND last_name < 'Francis' and birthday = '1989-02-14';


| id | select_type | table  | type  | possible_keys | key   | key_len | ref | rows | filtered |
|----|-------------|--------|-------|---------------|-------|---------|-----|------|----------|
|  1 | SIMPLE      | people | range | multi         | multi | 404     |     |   55 |    10.00 |
```

The key length remains 404 bytes, meaning MySQL stops using the index at the first range condition (last_name in this case) and doesn't use the birthday part of the index.

Choosing the right order for columns in a composite index depends on the access patterns of your application. Consider the following tips when defining composite indexes:

1. Equality conditions that are commonly used would be good candidates for being first in a composite index.

2. Range conditions or less frequently used columns would be better candidates for ordering later in the composite index.

Composite indexes can significantly improve the performance of your database queries. Understanding and effectively using them is essential for advanced database users. Remember to consider your access patterns and carefully define the order of your columns to create efficient composite indexes.